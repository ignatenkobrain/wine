From d61ce875649e81e0b74a0430c4ed44552427a7aa Mon Sep 17 00:00:00 2001
From: Axel Davy <axel.davy@ens.fr>
Date: Fri, 19 Sep 2014 20:37:34 +0200
Subject: [PATCH 07/18] d3dadapter: Begin DRI3 implementation

Signed-off-by: Axel Davy <axel.davy@ens.fr>
---
 dlls/winex11.drv/Makefile.in  |   4 +-
 dlls/winex11.drv/d3dadapter.c | 587 +++++++++++++++-------------------
 dlls/winex11.drv/dri2.c       | 430 -------------------------
 dlls/winex11.drv/dri2.h       | 101 ------
 dlls/winex11.drv/dri3.c       | 729 ++++++++++++++++++++++++++++++++++++++++++
 dlls/winex11.drv/dri3.h       |  85 +++++
 dlls/winex11.drv/init.c       |   2 +-
 dlls/winex11.drv/x11drv.h     |   2 +-
 8 files changed, 1072 insertions(+), 868 deletions(-)
 delete mode 100644 dlls/winex11.drv/dri2.c
 delete mode 100644 dlls/winex11.drv/dri2.h
 create mode 100644 dlls/winex11.drv/dri3.c
 create mode 100644 dlls/winex11.drv/dri3.h

diff --git a/dlls/winex11.drv/Makefile.in b/dlls/winex11.drv/Makefile.in
index 7b09215..41cced8 100644
--- a/dlls/winex11.drv/Makefile.in
+++ b/dlls/winex11.drv/Makefile.in
@@ -2,7 +2,7 @@ MODULE    = winex11.drv
 IMPORTS   = uuid user32 gdi32 advapi32
 DELAYIMPORTS = comctl32 ole32 shell32 imm32
 EXTRAINCL = $(X_CFLAGS)
-EXTRALIBS = $(X_LIBS) $(X_EXTRA_LIBS)
+EXTRALIBS = $(X_LIBS) $(X_EXTRA_LIBS) -lxcb -lxcb-dri3 -lxcb-present -lX11-xcb -lxcb-xfixes -lpthread
 
 C_SRCS = \
 	bitblt.c \
@@ -10,7 +10,7 @@ C_SRCS = \
 	clipboard.c \
 	d3dadapter.c \
 	desktop.c \
-	dri2.c \
+	dri3.c \
 	event.c \
 	graphics.c \
 	ime.c \
diff --git a/dlls/winex11.drv/d3dadapter.c b/dlls/winex11.drv/d3dadapter.c
index d4c0e77..7098651 100644
--- a/dlls/winex11.drv/d3dadapter.c
+++ b/dlls/winex11.drv/d3dadapter.c
@@ -38,21 +38,22 @@ WINE_DEFAULT_DEBUG_CHANNEL(d3dadapter);
 
 #include <d3dadapter/drm.h>
 
-#include <X11/Xlib.h>
 #include "xfixes.h"
-#include "dri2.h"
+#include "dri3.h"
 
 #include <libdrm/drm.h>
 #include <sys/ioctl.h>
 #include <errno.h>
 #include <fcntl.h>
 
-struct d3dadapter_info {
-    unsigned dri2_major, dri2_minor;
-};
+#ifndef D3DPRESENT_DONOTWAIT
+#define D3DPRESENT_DONOTWAIT      0x00000001
+#endif
+
+#define WINE_D3DADAPTER_DRIVER_PRESENT_VERSION_MAJOR 1
+#define WINE_D3DADAPTER_DRIVER_PRESENT_VERSION_MINOR 0
 
 static const struct D3DAdapter9DRM *d3d9_drm = NULL;
-static struct d3dadapter_info d3d_info;
 
 static XContext d3d_hwnd_context;
 static CRITICAL_SECTION context_section;
@@ -70,14 +71,12 @@ const GUID IID_ID3DPresentGroup = { 0xB9C3016E, 0xF32A, 0x11DF, { 0x9C, 0x18, 0x
 struct d3d_drawable
 {
     Drawable drawable; /* X11 drawable */
+    RECT dc_rect; /* rect relative to the X11 drawable */
     HDC hdc;
     HWND wnd; /* HWND (for convenience) */
-    RECT dc_rect; /* rect relative to the X11 drawable */
-    RECT dest_rect; /* dest rect used when creating the X11 region */
-    XserverRegion region; /* X11 region matching dc_rect */
 };
 
-struct DRI2Present
+struct DRI3Present
 {
     /* COM vtable */
     void *vtable;
@@ -86,22 +85,24 @@ struct DRI2Present
 
     D3DPRESENT_PARAMETERS params;
     HWND focus_wnd;
-
-    struct {
-        Drawable drawable;
-        XserverRegion region;
-    } cache;
+    PRESENTpriv *present_priv;
 
     WCHAR devname[32];
     HCURSOR hCursor;
+
+    DEVMODEW initial_mode;
+};
+
+struct D3DWindowBuffer
+{
+    Pixmap pixmap;
+    PRESENTPixmapPriv *present_pixmap_priv;
 };
 
 static void
 free_d3dadapter_drawable(struct d3d_drawable *d3d)
 {
-    DRI2DestroyDrawable(gdi_display, d3d->drawable);
     ReleaseDC(d3d->wnd, d3d->hdc);
-    if (d3d->region) { pXFixesDestroyRegion(gdi_display, d3d->region); }
     HeapFree(GetProcessHeap(), 0, d3d);
 }
 
@@ -144,16 +145,6 @@ create_d3dadapter_drawable(HWND hwnd)
     d3d->drawable = extesc.drawable;
     d3d->wnd = hwnd;
     d3d->dc_rect = extesc.dc_rect;
-    SetRect(&d3d->dest_rect, 0, 0, 0, 0);
-    d3d->region = 0; /* because of pDestRect, this is set later */
-
-    /*if (!DRI2CreateDrawable(gdi_display, d3d->drawable)) {
-        ERR("DRI2CreateDrawable failed (hwnd=%p, drawable=%u).\n",
-            hwnd, d3d->drawable);
-        HeapFree(GetProcessHeap(), 0, d3d);
-        return NULL;
-    }*/
-    DRI2CreateDrawable(gdi_display, d3d->drawable);
 
     return d3d;
 }
@@ -175,14 +166,8 @@ get_d3d_drawable(HWND hwnd)
                  hwnd, d3d->hdc);
         }
 
-        /* update the data and destroy the cached (now invalid) region */
-        if (!EqualRect(&d3d->dc_rect, &extesc.dc_rect)) {
+        if (!EqualRect(&d3d->dc_rect, &extesc.dc_rect))
             d3d->dc_rect = extesc.dc_rect;
-            if (d3d->region) {
-                pXFixesDestroyRegion(gdi_display, d3d->region);
-                d3d->region = 0;
-            }
-        }
 
         return d3d;
     }
@@ -212,7 +197,7 @@ release_d3d_drawable(struct d3d_drawable *d3d)
 }
 
 static ULONG WINAPI
-DRI2Present_AddRef( struct DRI2Present *This )
+DRI3Present_AddRef( struct DRI3Present *This )
 {
     ULONG refs = InterlockedIncrement(&This->refs);
     TRACE("%p increasing refcount to %u.\n", This, refs);
@@ -220,19 +205,21 @@ DRI2Present_AddRef( struct DRI2Present *This )
 }
 
 static ULONG WINAPI
-DRI2Present_Release( struct DRI2Present *This )
+DRI3Present_Release( struct DRI3Present *This )
 {
     ULONG refs = InterlockedDecrement(&This->refs);
     TRACE("%p decreasing refcount to %u.\n", This, refs);
     if (refs == 0) {
         /* dtor */
+        ChangeDisplaySettingsExW(This->devname, &(This->initial_mode), 0, CDS_FULLSCREEN, NULL);
+        PRESENTDestroy(gdi_display, This->present_priv);
         HeapFree(GetProcessHeap(), 0, This);
     }
     return refs;
 }
 
 static HRESULT WINAPI
-DRI2Present_QueryInterface( struct DRI2Present *This,
+DRI3Present_QueryInterface( struct DRI3Present *This,
                             REFIID riid,
                             void **ppvObject )
 {
@@ -241,7 +228,7 @@ DRI2Present_QueryInterface( struct DRI2Present *This,
     if (IsEqualGUID(&IID_ID3DPresent, riid) ||
         IsEqualGUID(&IID_IUnknown, riid)) {
         *ppvObject = This;
-        DRI2Present_AddRef(This);
+        DRI3Present_AddRef(This);
         return S_OK;
     }
 
@@ -252,160 +239,126 @@ DRI2Present_QueryInterface( struct DRI2Present *This,
 }
 
 static HRESULT WINAPI
-DRI2Present_GetPresentParameters( struct DRI2Present *This,
+DRI3Present_GetPresentParameters( struct DRI3Present *This,
                                   D3DPRESENT_PARAMETERS *pPresentationParameters )
 {
     *pPresentationParameters = This->params;
     return D3D_OK;
 }
 
+static void
+DRI3Present_ChangePresentParameters( struct DRI3Present *This,
+                                    D3DPRESENT_PARAMETERS *params,
+                                    BOOL first_time);
+
 static HRESULT WINAPI
-DRI2Present_GetBuffer( struct DRI2Present *This,
-                              HWND hWndOverride,
-                              void *pBuffer,
-                              const RECT *pDestRect,
-                              RECT *pRect,
-                              RGNDATA **ppRegion )
+DRI3Present_SetPresentParameters( struct DRI3Present *This,
+                                  D3DPRESENT_PARAMETERS *pPresentationParameters )
 {
-    static const unsigned attachments[] = { DRI2BufferBackLeft };
-
-    struct d3d_drawable *d3d;
-    D3DDRM_BUFFER *drmbuf = pBuffer;
-    DRI2Buffer *buffers;
-    RECT dest;
-    unsigned width, height, n;
-
-    TRACE("(This=%p, hWndOverride=%p, pBuffer=%p, pRect=%p, ppRegion=%p)\n",
-          This, hWndOverride, pBuffer, pRect, ppRegion);
-
-    if (hWndOverride) {
-        d3d = get_d3d_drawable(hWndOverride);
-    } else if (This->params.hDeviceWindow) {
-        d3d = get_d3d_drawable(This->params.hDeviceWindow);
-    } else {
-        d3d = get_d3d_drawable(This->focus_wnd);
-    }
-    if (!d3d) { return D3DERR_DRIVERINTERNALERROR; }
-
-    {
-        /* TODO: don't pass rgndata to the driver, but use it for DRI2CopyRegion
-        DWORD rgn_size;
-        HRGN hrgn = CreateRectRgn(0, 0, 0, 0);
-        if (GetWindowRgn(This->current_window.real, hrgn) != _ERROR) {
-            rgn_size = GetRegionData(hrgn, 0, NULL);
-            This->rgndata = HeapAlloc(GetProcessHeap(), 0, rgn_size);
-            GetRegionData(hrgn, rgn_size, This->rgndata);
-        }
-        DeleteObject(hrgn);
-        if (!This->rgndata) {
-            return D3DERR_DRIVERINTERNALERROR;
-        }*/
-        *ppRegion = NULL;
-    }
+    DRI3Present_ChangePresentParameters(This, pPresentationParameters, FALSE);
+    return D3D_OK;
+}
 
-    /* XXX base this on events instead of calling every single frame */
-    if ((n = DRI2GetBuffers(gdi_display, d3d->drawable, attachments, 1,
-                            &width, &height, &buffers)) < 1) {
-        ERR("DRI2GetBuffers failed (drawable=%u, n=%u)\n",
-            (unsigned)d3d->drawable, n);
-        release_d3d_drawable(d3d);
+static HRESULT WINAPI
+DRI3Present_D3DWindowBufferFromDmaBuf( struct DRI3Present *This,
+                       int dmaBufFd,
+                       int width,
+                       int height,
+                       int stride,
+                       int depth,
+                       int bpp,
+                       struct D3DWindowBuffer **out)
+{
+    Pixmap pixmap;
+
+    if (!DRI3PixmapFromDmaBuf(gdi_display, DefaultScreen(gdi_display),
+                              dmaBufFd, width, height, stride, depth,
+                              bpp, &pixmap ))
         return D3DERR_DRIVERINTERNALERROR;
-    }
-
-    drmbuf->iName = buffers[0].name;
-    drmbuf->dwWidth = width;
-    drmbuf->dwHeight = height;
-    drmbuf->dwStride = buffers[0].pitch;
-    drmbuf->dwCPP = buffers[0].cpp;
-    HeapFree(GetProcessHeap(), 0, buffers);
-
-    /* return the offset region to the driver */
-    pRect->left = d3d->dc_rect.left;
-    pRect->top = d3d->dc_rect.top;
-    pRect->right = d3d->dc_rect.right;
-    pRect->bottom = d3d->dc_rect.bottom;
-
-    TRACE("pRect=(%u..%u)x(%u..%u)\n",
-          pRect->left, pRect->right, pRect->top, pRect->bottom);
-
-    /* if pDestRect is set, calculate the final region */
-    dest = *pRect;
-    if (pDestRect) {
-        dest.left += pDestRect->left;
-        dest.top += pDestRect->top;
-        dest.right = pDestRect->right + dest.left;
-        dest.bottom = pDestRect->bottom + dest.top;
-        if (dest.left > pRect->right) { dest.left = pRect->right; }
-        if (dest.top > pRect->bottom) { dest.top = pRect->bottom; }
-        if (dest.right > pRect->right) { dest.right = pRect->right; }
-        if (dest.bottom > pRect->bottom) { dest.bottom = pRect->bottom; }
-
-        TRACE("dest=(%u..%u)x(%u..%u)\n",
-              dest.left, dest.right, dest.top, dest.bottom);
-    }
-
-    /* if the new dest region doesn't match the cached one, destroy it */
-    if (!EqualRect(&d3d->dest_rect, &dest) && d3d->region) {
-        pXFixesDestroyRegion(gdi_display, d3d->region);
-        d3d->region = 0;
-    }
-
-    /* create region to match the new destination */
-    if (!d3d->region) {
-        XRectangle xrect;
-
-        xrect.x = dest.left;
-        xrect.y = dest.top;
-        xrect.width = dest.right - dest.left;
-        xrect.height = dest.bottom - dest.top;
 
-        d3d->region = pXFixesCreateRegion(gdi_display, &xrect, 1);
-        d3d->dest_rect = dest;
-
-        TRACE("XFixes rect (x=%u, y=%u, w=%u, h=%u)\n",
-              xrect.x, xrect.y, xrect.width, xrect.height);
-    }
-
-    This->cache.drawable = d3d->drawable;
-    This->cache.region = d3d->region;
+    *out = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
+                    sizeof(struct D3DWindowBuffer));
+    (*out)->pixmap = pixmap;
+    PRESENTPixmapInit(This->present_priv, pixmap, &((*out)->present_pixmap_priv));
+    return D3D_OK;
+}
 
-    release_d3d_drawable(d3d);
+static HRESULT WINAPI
+DRI3Present_DestroyD3DWindowBuffer( struct DRI3Present *This,
+                           struct D3DWindowBuffer *buffer )
+{
+    /* the pixmap is managed by the PRESENT backend.
+     * But if it can delete it right away, we may have
+     * better performance */
+    PRESENTTryFreePixmap(buffer->present_pixmap_priv);
+    HeapFree(GetProcessHeap(), 0, buffer);
+    return D3D_OK;
+}
 
+static HRESULT WINAPI
+DRI3Present_WaitBufferReleased( struct DRI3Present *This,
+                                struct D3DWindowBuffer *buffer)
+{
+    PRESENTWaitPixmapReleased(buffer->present_pixmap_priv);
     return D3D_OK;
 }
 
 static HRESULT WINAPI
-DRI2Present_GetFrontBuffer( struct DRI2Present *This,
-                            void *pBuffer )
+DRI3Present_FrontBufferCopy( struct DRI3Present *This,
+                             struct D3DWindowBuffer *buffer )
 {
-    FIXME("(%p, %p), stub!\n", This, pBuffer);
-    return D3DERR_INVALIDCALL;
+    /* TODO: use dc_rect */
+    if (PRESENTHelperCopyFront(gdi_display, buffer->present_pixmap_priv))
+        return D3D_OK;
+    else
+        return D3DERR_DRIVERINTERNALERROR;
 }
 
 static HRESULT WINAPI
-DRI2Present_Present( struct DRI2Present *This,
-                     DWORD Flags )
+DRI3Present_PresentBuffer( struct DRI3Present *This,
+                           struct D3DWindowBuffer *buffer,
+                           HWND hWndOverride,
+                           const RECT *pSourceRect,
+                           const RECT *pDestRect,
+                           const RGNDATA *pDirtyRegion,
+                           DWORD Flags )
 {
-    TRACE("(This=%p, Flags=%x)\n", This, Flags);
+    struct d3d_drawable *d3d;
+    RECT dest_translate;
 
-    XFlush(gdi_display);
+    if (hWndOverride) {
+        d3d = get_d3d_drawable(hWndOverride);
+    } else if (This->params.hDeviceWindow) {
+        d3d = get_d3d_drawable(This->params.hDeviceWindow);
+    } else {
+        d3d = get_d3d_drawable(This->focus_wnd);
+    }
+    if (!d3d) { return D3DERR_DRIVERINTERNALERROR; }
 
-    if (1/*This->dri2_minor < 3*/) {
-        if (!DRI2CopyRegion(gdi_display, This->cache.drawable,
-                            This->cache.region, DRI2BufferFrontLeft,
-                            DRI2BufferBackLeft)) {
-            ERR("DRI2CopyRegion failed (drawable=%u, region=%u)\n",
-                (unsigned)This->cache.drawable, (unsigned)This->cache.region);
-            return D3DERR_DRIVERINTERNALERROR;
+    if (d3d->dc_rect.top != 0 &&
+        d3d->dc_rect.left != 0) {
+        if (!pDestRect)
+            pDestRect = (const RECT *) &(d3d->dc_rect);
+        else {
+            dest_translate.top = pDestRect->top + d3d->dc_rect.top;
+            dest_translate.left = pDestRect->left + d3d->dc_rect.left;
+            dest_translate.bottom = pDestRect->bottom + d3d->dc_rect.bottom;
+            dest_translate.right = pDestRect->right + d3d->dc_rect.right;
+            pDestRect = (const RECT *) &dest_translate;
         }
-        /* XXX if (!(Flags & D3DPRESENT_DONOTWAIT)) { */
     }
 
+    if (!PRESENTPixmap(gdi_display, d3d->drawable, buffer->present_pixmap_priv,
+                       &This->params, pSourceRect, pDestRect, pDirtyRegion))
+        return D3DERR_DRIVERINTERNALERROR;
+
+    release_d3d_drawable(d3d);
+
     return D3D_OK;
 }
 
 static HRESULT WINAPI
-DRI2Present_GetRasterStatus( struct DRI2Present *This,
+DRI3Present_GetRasterStatus( struct DRI3Present *This,
                              D3DRASTER_STATUS *pRasterStatus )
 {
     FIXME("(%p, %p), stub!\n", This, pRasterStatus);
@@ -413,7 +366,7 @@ DRI2Present_GetRasterStatus( struct DRI2Present *This,
 }
 
 static HRESULT WINAPI
-DRI2Present_GetDisplayMode( struct DRI2Present *This,
+DRI3Present_GetDisplayMode( struct DRI3Present *This,
                             D3DDISPLAYMODEEX *pMode,
                             D3DDISPLAYROTATION *pRotation )
 {
@@ -454,7 +407,7 @@ DRI2Present_GetDisplayMode( struct DRI2Present *This,
 }
 
 static HRESULT WINAPI
-DRI2Present_GetPresentStats( struct DRI2Present *This,
+DRI3Present_GetPresentStats( struct DRI3Present *This,
                              D3DPRESENTSTATS *pStats )
 {
     FIXME("(%p, %p), stub!\n", This, pStats);
@@ -462,7 +415,7 @@ DRI2Present_GetPresentStats( struct DRI2Present *This,
 }
 
 static HRESULT WINAPI
-DRI2Present_GetCursorPos( struct DRI2Present *This,
+DRI3Present_GetCursorPos( struct DRI3Present *This,
                           POINT *pPoint )
 {
     BOOL ok;
@@ -474,7 +427,7 @@ DRI2Present_GetCursorPos( struct DRI2Present *This,
 }
 
 static HRESULT WINAPI
-DRI2Present_SetCursorPos( struct DRI2Present *This,
+DRI3Present_SetCursorPos( struct DRI3Present *This,
                           POINT *pPoint )
 {
     if (!pPoint)
@@ -483,7 +436,7 @@ DRI2Present_SetCursorPos( struct DRI2Present *This,
 }
 
 static HRESULT WINAPI
-DRI2Present_SetCursor( struct DRI2Present *This,
+DRI3Present_SetCursor( struct DRI3Present *This,
                        void *pBitmap,
                        POINT *pHotspot,
                        BOOL bShow )
@@ -516,7 +469,7 @@ DRI2Present_SetCursor( struct DRI2Present *This,
 }
 
 static HRESULT WINAPI
-DRI2Present_SetGammaRamp( struct DRI2Present *This,
+DRI3Present_SetGammaRamp( struct DRI3Present *This,
                           const D3DGAMMARAMP *pRamp,
                           HWND hWndOverride )
 {
@@ -533,13 +486,22 @@ DRI2Present_SetGammaRamp( struct DRI2Present *This,
 }
 
 static HRESULT WINAPI
-DRI2Present_GetWindowRect( struct DRI2Present *This,
+DRI3Present_GetWindowInfo( struct DRI3Present *This,
                            HWND hWnd,
-                           LPRECT pRect )
+                           int *width, int *height, int *depth )
 {
+    HRESULT hr;
+    RECT pRect;
+
     if (!hWnd)
         hWnd = This->focus_wnd;
-    return GetClientRect(hWnd, pRect) ? D3D_OK : D3DERR_INVALIDCALL;
+    hr = GetClientRect(hWnd, &pRect);
+    if (!hr)
+        return D3DERR_INVALIDCALL;
+    *width = pRect.right - pRect.left;
+    *height = pRect.bottom - pRect.top;
+    *depth = 24; //TODO
+    return D3D_OK;
 }
 
 static LONG fullscreen_style(LONG style)
@@ -563,74 +525,39 @@ static LONG fullscreen_exstyle(LONG exstyle)
 /*----------*/
 
 
-static ID3DPresentVtbl DRI2Present_vtable = {
-    (void *)DRI2Present_QueryInterface,
-    (void *)DRI2Present_AddRef,
-    (void *)DRI2Present_Release,
-    (void *)DRI2Present_GetPresentParameters,
-    (void *)DRI2Present_GetBuffer,
-    (void *)DRI2Present_GetFrontBuffer,
-    (void *)DRI2Present_Present,
-    (void *)DRI2Present_GetRasterStatus,
-    (void *)DRI2Present_GetDisplayMode,
-    (void *)DRI2Present_GetPresentStats,
-    (void *)DRI2Present_GetCursorPos,
-    (void *)DRI2Present_SetCursorPos,
-    (void *)DRI2Present_SetCursor,
-    (void *)DRI2Present_SetGammaRamp,
-    (void *)DRI2Present_GetWindowRect
+static ID3DPresentVtbl DRI3Present_vtable = {
+    (void *)DRI3Present_QueryInterface,
+    (void *)DRI3Present_AddRef,
+    (void *)DRI3Present_Release,
+    (void *)DRI3Present_GetPresentParameters,
+    (void *)DRI3Present_SetPresentParameters,
+    (void *)DRI3Present_D3DWindowBufferFromDmaBuf,
+    (void *)DRI3Present_DestroyD3DWindowBuffer,
+    (void *)DRI3Present_WaitBufferReleased,
+    (void *)DRI3Present_FrontBufferCopy,
+    (void *)DRI3Present_PresentBuffer,
+    (void *)DRI3Present_GetRasterStatus,
+    (void *)DRI3Present_GetDisplayMode,
+    (void *)DRI3Present_GetPresentStats,
+    (void *)DRI3Present_GetCursorPos,
+    (void *)DRI3Present_SetCursorPos,
+    (void *)DRI3Present_SetCursor,
+    (void *)DRI3Present_SetGammaRamp,
+    (void *)DRI3Present_GetWindowInfo
 };
 
-static HRESULT
-DRI2Present_new( Display *dpy,
-                 const WCHAR *devname,
-                 D3DPRESENT_PARAMETERS *params,
-                 HWND focus_wnd,
-                 struct DRI2Present **out )
+static void
+DRI3Present_ChangePresentParameters( struct DRI3Present *This,
+                                    D3DPRESENT_PARAMETERS *params,
+                                    BOOL first_time)
 {
-    struct DRI2Present *This;
     HWND draw_window;
     RECT rect;
 
-    if (!focus_wnd) { focus_wnd = params->hDeviceWindow; }
-    if (!focus_wnd) {
-        ERR("No focus HWND specified for presentation backend.\n");
-        return D3DERR_INVALIDCALL;
-    }
-    draw_window = params->hDeviceWindow ? params->hDeviceWindow : focus_wnd;
-
-    This = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
-                     sizeof(struct DRI2Present));
-    if (!This) {
-        ERR("Out of memory.\n");
-        return E_OUTOFMEMORY;
-    }
-
-    This->vtable = &DRI2Present_vtable;
-    This->refs = 1;
-    This->focus_wnd = focus_wnd;
-
+    (void) first_time; /* will be used to manage screen res if windowed mode change /*
+    /* TODO: don't do anything if nothing changed */
     /* sanitize presentation parameters */
-    if (params->SwapEffect == D3DSWAPEFFECT_COPY &&
-        params->BackBufferCount > 1) {
-        WARN("present: BackBufferCount > 1 when SwapEffect == "
-             "D3DSWAPEFFECT_COPY.\n");
-        params->BackBufferCount = 1;
-    }
-
-    /* XXX 30 for Ex */
-    if (params->BackBufferCount > 3) {
-        WARN("present: BackBufferCount > 3.\n");
-        params->BackBufferCount = 3;
-    }
-
-    if (params->BackBufferCount == 0) {
-        params->BackBufferCount = 1;
-    }
-
-    if (params->BackBufferFormat == D3DFMT_UNKNOWN) {
-        params->BackBufferFormat = D3DFMT_A8R8G8B8;
-    }
+    draw_window = params->hDeviceWindow ? params->hDeviceWindow : This->focus_wnd;
 
     if (!GetClientRect(draw_window, &rect)) {
         WARN("GetClientRect failed.\n");
@@ -639,50 +566,89 @@ DRI2Present_new( Display *dpy,
     }
 
     if (params->BackBufferWidth == 0) {
-        params->BackBufferWidth = rect.right;
+        params->BackBufferWidth = rect.right - rect.left;
     }
     if (params->BackBufferHeight == 0) {
-        params->BackBufferHeight = rect.bottom;
+        params->BackBufferHeight = rect.bottom - rect.top;
     }
 
     if (!params->Windowed) {
+        /* TODO Store initial config and restore it when leaving fullscreen, or when leaving wine*/
         LONG style, exstyle;
         DEVMODEW newMode;
 
         newMode.dmPelsWidth = params->BackBufferWidth;
         newMode.dmPelsHeight = params->BackBufferHeight;
         newMode.dmFields = DM_PELSWIDTH | DM_PELSHEIGHT;
-        ChangeDisplaySettingsExW(devname,&newMode,0,CDS_FULLSCREEN,NULL);
+        ChangeDisplaySettingsExW(This->devname, &newMode, 0, CDS_FULLSCREEN, NULL);
 
         style = fullscreen_style(0);
         exstyle = fullscreen_exstyle(0);
 
-        SetWindowLongW(focus_wnd, GWL_STYLE, style);
-        SetWindowLongW(focus_wnd, GWL_EXSTYLE, exstyle);
-        SetWindowPos(focus_wnd,HWND_TOPMOST,0,0,params->BackBufferWidth,params->BackBufferHeight,SWP_FRAMECHANGED | SWP_SHOWWINDOW | SWP_NOACTIVATE);
-    }
+        SetWindowLongW(draw_window, GWL_STYLE, style);
+        SetWindowLongW(draw_window, GWL_EXSTYLE, exstyle);
+        SetWindowPos(draw_window, HWND_TOPMOST, 0, 0, params->BackBufferWidth, params->BackBufferHeight, SWP_FRAMECHANGED | SWP_SHOWWINDOW | SWP_NOACTIVATE);
+    } else if (!first_time && !This->params.Windowed)
+        ChangeDisplaySettingsExW(This->devname, &(This->initial_mode), 0, CDS_FULLSCREEN, NULL);
 
     This->params = *params;
+}
+
+static HRESULT
+DRI3Present_new( Display *dpy,
+                 const WCHAR *devname,
+                 D3DPRESENT_PARAMETERS *params,
+                 HWND focus_wnd,
+                 struct DRI3Present **out )
+{
+    struct DRI3Present *This;
+
+    if (!focus_wnd) { focus_wnd = params->hDeviceWindow; }
+    if (!focus_wnd) {
+        ERR("No focus HWND specified for presentation backend.\n");
+        return D3DERR_INVALIDCALL;
+    }
+
+    This = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
+                     sizeof(struct DRI3Present));
+    if (!This) {
+        ERR("Out of memory.\n");
+        return E_OUTOFMEMORY;
+    }
+
+    This->vtable = &DRI3Present_vtable;
+    This->refs = 1;
+    This->focus_wnd = focus_wnd;
+
     strcpyW(This->devname, devname);
 
+    ZeroMemory(&(This->initial_mode), sizeof(This->initial_mode));
+    This->initial_mode.dmSize = sizeof(This->initial_mode);
+
+    EnumDisplaySettingsExW(This->devname, ENUM_CURRENT_SETTINGS, &(This->initial_mode), 0);
+
+    DRI3Present_ChangePresentParameters(This, params, TRUE);
+
+    PRESENTInit(dpy, &(This->present_priv));
+
     *out = This;
 
     return D3D_OK;
 }
 
-struct DRI2PresentGroup
+struct DRI3PresentGroup
 {
     /* COM vtable */
     void *vtable;
     /* IUnknown reference count */
     LONG refs;
 
-    struct DRI2Present **present_backends;
+    struct DRI3Present **present_backends;
     unsigned npresent_backends;
 };
 
 static ULONG WINAPI
-DRI2PresentGroup_AddRef( struct DRI2PresentGroup *This )
+DRI3PresentGroup_AddRef( struct DRI3PresentGroup *This )
 {
     ULONG refs = InterlockedIncrement(&This->refs);
     TRACE("%p increasing refcount to %u.\n", This, refs);
@@ -690,7 +656,7 @@ DRI2PresentGroup_AddRef( struct DRI2PresentGroup *This )
 }
 
 static ULONG WINAPI
-DRI2PresentGroup_Release( struct DRI2PresentGroup *This )
+DRI3PresentGroup_Release( struct DRI3PresentGroup *This )
 {
     ULONG refs = InterlockedDecrement(&This->refs);
     TRACE("%p decreasing refcount to %u.\n", This, refs);
@@ -698,7 +664,7 @@ DRI2PresentGroup_Release( struct DRI2PresentGroup *This )
         unsigned i;
         if (This->present_backends) {
             for (i = 0; i < This->npresent_backends; ++i) {
-                DRI2Present_Release(This->present_backends[i]);
+                DRI3Present_Release(This->present_backends[i]);
             }
             HeapFree(GetProcessHeap(), 0, This->present_backends);
         }
@@ -708,7 +674,7 @@ DRI2PresentGroup_Release( struct DRI2PresentGroup *This )
 }
 
 static HRESULT WINAPI
-DRI2PresentGroup_QueryInterface( struct DRI2PresentGroup *This,
+DRI3PresentGroup_QueryInterface( struct DRI3PresentGroup *This,
                                  REFIID riid,
                                  void **ppvObject )
 {
@@ -716,7 +682,7 @@ DRI2PresentGroup_QueryInterface( struct DRI2PresentGroup *This,
     if (IsEqualGUID(&IID_ID3DPresentGroup, riid) ||
         IsEqualGUID(&IID_IUnknown, riid)) {
         *ppvObject = This;
-        DRI2PresentGroup_AddRef(This);
+        DRI3PresentGroup_AddRef(This);
         return S_OK;
     }
 
@@ -727,29 +693,29 @@ DRI2PresentGroup_QueryInterface( struct DRI2PresentGroup *This,
 }
 
 static UINT WINAPI
-DRI2PresentGroup_GetMultiheadCount( struct DRI2PresentGroup *This )
+DRI3PresentGroup_GetMultiheadCount( struct DRI3PresentGroup *This )
 {
     FIXME("(%p), stub!\n", This);
     return 1;
 }
 
 static HRESULT WINAPI
-DRI2PresentGroup_GetPresent( struct DRI2PresentGroup *This,
+DRI3PresentGroup_GetPresent( struct DRI3PresentGroup *This,
                              UINT Index,
                              ID3DPresent **ppPresent )
 {
-    if (Index >= DRI2PresentGroup_GetMultiheadCount(This)) {
+    if (Index >= DRI3PresentGroup_GetMultiheadCount(This)) {
         ERR("Index >= MultiHeadCount\n");
         return D3DERR_INVALIDCALL;
     }
-    DRI2Present_AddRef(This->present_backends[Index]);
+    DRI3Present_AddRef(This->present_backends[Index]);
     *ppPresent = (ID3DPresent *)This->present_backends[Index];
 
     return D3D_OK;
 }
 
 static HRESULT WINAPI
-DRI2PresentGroup_CreateAdditionalPresent( struct DRI2PresentGroup *This,
+DRI3PresentGroup_CreateAdditionalPresent( struct DRI3PresentGroup *This,
                                           D3DPRESENT_PARAMETERS *pPresentationParameters,
                                           ID3DPresent **ppPresent )
 {
@@ -757,26 +723,36 @@ DRI2PresentGroup_CreateAdditionalPresent( struct DRI2PresentGroup *This,
     return D3DERR_INVALIDCALL;
 }
 
-static ID3DPresentGroupVtbl DRI2PresentGroup_vtable = {
-    (void *)DRI2PresentGroup_QueryInterface,
-    (void *)DRI2PresentGroup_AddRef,
-    (void *)DRI2PresentGroup_Release,
-    (void *)DRI2PresentGroup_GetMultiheadCount,
-    (void *)DRI2PresentGroup_GetPresent,
-    (void *)DRI2PresentGroup_CreateAdditionalPresent
+static void WINAPI
+DRI3PresentGroup_GetVersion( struct DRI3PresentGroup *This,
+                             int *major,
+                             int *minor)
+{
+    *major = WINE_D3DADAPTER_DRIVER_PRESENT_VERSION_MAJOR;
+    *minor = WINE_D3DADAPTER_DRIVER_PRESENT_VERSION_MINOR;
+}
+
+static ID3DPresentGroupVtbl DRI3PresentGroup_vtable = {
+    (void *)DRI3PresentGroup_QueryInterface,
+    (void *)DRI3PresentGroup_AddRef,
+    (void *)DRI3PresentGroup_Release,
+    (void *)DRI3PresentGroup_GetMultiheadCount,
+    (void *)DRI3PresentGroup_GetPresent,
+    (void *)DRI3PresentGroup_CreateAdditionalPresent,
+    (void *)DRI3PresentGroup_GetVersion
 };
 
 static HRESULT
-dri2_create_present_group( const WCHAR *device_name,
+dri3_create_present_group( const WCHAR *device_name,
                            UINT adapter,
                            HWND focus_wnd,
                            D3DPRESENT_PARAMETERS *params,
                            unsigned nparams,
                            ID3DPresentGroup **group )
 {
-    struct DRI2PresentGroup *This =
+    struct DRI3PresentGroup *This =
         HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
-                  sizeof(struct DRI2PresentGroup));
+                  sizeof(struct DRI3PresentGroup));
     DISPLAY_DEVICEW dd;
     HRESULT hr;
     unsigned i;
@@ -786,14 +762,14 @@ dri2_create_present_group( const WCHAR *device_name,
         return E_OUTOFMEMORY;
     }
 
-    This->vtable = &DRI2PresentGroup_vtable;
+    This->vtable = &DRI3PresentGroup_vtable;
     This->refs = 1;
     This->npresent_backends = nparams;
     This->present_backends = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
                                        This->npresent_backends *
-                                       sizeof(struct DRI2Present *));
+                                       sizeof(struct DRI3Present *));
     if (!This->present_backends) {
-        DRI2PresentGroup_Release(This);
+        DRI3PresentGroup_Release(This);
         ERR("Out of memory.\n");
         return E_OUTOFMEMORY;
     }
@@ -807,10 +783,10 @@ dri2_create_present_group( const WCHAR *device_name,
         }
 
         /* create an ID3DPresent for it */
-        hr = DRI2Present_new(gdi_display, dd.DeviceName, &params[i],
+        hr = DRI3Present_new(gdi_display, dd.DeviceName, &params[i],
                              focus_wnd, &This->present_backends[i]);
         if (FAILED(hr)) {
-            DRI2PresentGroup_Release(This);
+            DRI3PresentGroup_Release(This);
             return hr;
         }
     }
@@ -822,12 +798,10 @@ dri2_create_present_group( const WCHAR *device_name,
 }
 
 static HRESULT
-dri2_create_adapter9( HDC hdc,
+dri3_create_adapter9( HDC hdc,
                       ID3DAdapter9 **out )
 {
     struct x11drv_escape_get_drawable extesc = { X11DRV_GET_DRAWABLE };
-    drm_auth_t auth;
-    Window root;
     HRESULT hr;
     int fd;
 
@@ -841,53 +815,8 @@ dri2_create_adapter9( HDC hdc,
         WARN("X11 drawable lookup failed (hdc=%p)\n", hdc);
     }
 
-    { /* XGetGeometry */
-        unsigned udummy;
-        int dummy;
-
-        if (!XGetGeometry(gdi_display, extesc.drawable, &root, &dummy, &dummy,
-                          &udummy, &udummy, &udummy, &udummy)) {
-            WARN("XGetGeometry: Unable to get root window (drawable=%u)\n",
-                 (unsigned)extesc.drawable);
-            root = (Window)extesc.drawable; /* cross your fingers */
-        }
-    }
-
-    { /* DRI2Connect */
-        char *driver, *device;
-
-        if (!DRI2Connect(gdi_display, root, DRI2DriverDRI, &driver, &device)) {
-            WARN("DRI2Connect: Unable to connect DRI2 (window=%u)\n",
-                 (unsigned)root);
-            return D3DERR_DRIVERINTERNALERROR;
-        }
-
-        fd = open(device, O_RDWR);
-        if (fd < 0) {
-            WARN("Failed to open drm fd: %s (%s)\n", strerror(errno), device);
-            HeapFree(GetProcessHeap(), 0, driver);
-            HeapFree(GetProcessHeap(), 0, device);
-            return D3DERR_DRIVERINTERNALERROR;
-        }
-
-        /* authenticate */
-        if (ioctl(fd, DRM_IOCTL_GET_MAGIC, &auth) != 0) {
-            WARN("DRM_IOCTL_GET_MAGIC failed: %s (%s)\n",
-                 strerror(errno), device);
-            HeapFree(GetProcessHeap(), 0, driver);
-            HeapFree(GetProcessHeap(), 0, device);
-            return D3DERR_DRIVERINTERNALERROR;
-        }
-
-        TRACE("Associated `%s' with fd %d opened from `%s'\n",
-              driver, fd, device);
-
-        HeapFree(GetProcessHeap(), 0, driver);
-        HeapFree(GetProcessHeap(), 0, device);
-    }
-
-    if (!DRI2Authenticate(gdi_display, root, auth.magic)) {
-        WARN("DRI2Authenticate failed (fd=%d)\n", fd);
+    if (!DRI3Open(gdi_display, DefaultScreen(gdi_display), &fd)) {
+        WARN("DRI3Open failed (fd=%d)\n", fd);
         return D3DERR_DRIVERINTERNALERROR;
     }
 
@@ -957,19 +886,11 @@ has_d3dadapter( void )
     /* this will be used to store d3d_drawables */
     d3d_hwnd_context = XUniqueContext();
 
-    /* query DRI2 */
-    d3d_info.dri2_major = DRI2_MAJOR;
-    d3d_info.dri2_minor = DRI2_MINOR;
-    if (!DRI2QueryExtension(gdi_display)) {
-        ERR("Xserver doesn't support DRI2.\n");
-        return D3DERR_DRIVERINTERNALERROR;
-    }
-    if (!DRI2QueryVersion(gdi_display, &d3d_info.dri2_major,
-                          &d3d_info.dri2_minor)) {
-        ERR("Unable to query DRI2 extension.\n");
-        return D3DERR_DRIVERINTERNALERROR;
+    if (!DRI3CheckExtension(gdi_display, 1, 0) ||
+        !PRESENTCheckExtension(gdi_display, 1, 0)) {
+        ERR("Unable to query DRI3 or PRESENT\n");
+        goto cleanup;
     }
-    TRACE("Got DRI2 version %u.%u\n", d3d_info.dri2_major, d3d_info.dri2_minor);
 
     /* query XFixes */
     if (!pXFixesQueryVersion(gdi_display, &xfmaj, &xfmin)) {
@@ -990,20 +911,20 @@ cleanup:
     return FALSE;
 }
 
-static struct d3dadapter_funcs dri2_driver = {
-    dri2_create_present_group,          /* create_present_group */
-    dri2_create_adapter9,               /* create_adapter9 */
+static struct d3dadapter_funcs dri3_driver = {
+    dri3_create_present_group,          /* create_present_group */
+    dri3_create_adapter9,               /* create_adapter9 */
 };
 
 struct d3dadapter_funcs *
-get_d3d_dri2_driver(UINT version)
+get_d3d_dri3_driver(UINT version)
 {
     if (version != WINE_D3DADAPTER_DRIVER_VERSION) {
         ERR("Version mismatch. d3d* wants %u but winex11 has "
             "version %u\n", version, WINE_D3DADAPTER_DRIVER_VERSION);
         return NULL;
     }
-    if (has_d3dadapter()) { return &dri2_driver; }
+    if (has_d3dadapter()) { return &dri3_driver; }
     return NULL;
 }
 
@@ -1027,7 +948,7 @@ has_d3dadapter( void )
 }
 
 struct d3dadapter_funcs *
-get_d3d_dri2_driver(UINT version)
+get_d3d_dri3_driver(UINT version)
 {
     return NULL;
 }
diff --git a/dlls/winex11.drv/dri2.c b/dlls/winex11.drv/dri2.c
deleted file mode 100644
index d42102c..0000000
--- a/dlls/winex11.drv/dri2.c
+++ /dev/null
@@ -1,430 +0,0 @@
-/*
- * Wine X11DRV DRI2 interface
- *
- * Copyright 2013 Joakim Sindholt
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
- */
-
-#include "config.h"
-#include "wine/debug.h"
-
-WINE_DEFAULT_DEBUG_CHANNEL(x11drv);
-
-#if defined(SONAME_LIBXEXT) && defined(SONAME_LIBXFIXES)
-
-#include "x11drv.h"
-#include <X11/Xlibint.h>
-#include <X11/extensions/dri2proto.h>
-#include <X11/extensions/extutil.h>
-
-#include "dri2.h"
-
-#include <stdio.h>
-
-static XExtensionInfo _dri2_info_data;
-static XExtensionInfo *dri2_info = &_dri2_info_data;
-static char dri2_name[] = DRI2_NAME;
-
-#define DRI2CheckExtension(dpy, i, val) \
-  XextCheckExtension(dpy, i, dri2_name, val)
-
-static int
-close_display( Display *dpy,
-               XExtCodes *codes );
-
-static Bool
-wire_to_event( Display *dpy,
-               XEvent *re,
-               xEvent *event );
-
-static Status
-event_to_wire( Display *dpy,
-               XEvent *re,
-               xEvent *event );
-
-static int
-error( Display *dpy,
-       xError *err,
-       XExtCodes *codes,
-       int *ret_code );
-
-static XExtensionHooks dri2_hooks = {
-  NULL,             /* create_gc */
-  NULL,             /* copy_gc */
-  NULL,             /* flush_gc */
-  NULL,             /* free_gc */
-  NULL,             /* create_font */
-  NULL,             /* free_font */
-  close_display,    /* close_display */
-  wire_to_event,    /* wire_to_event */
-  event_to_wire,    /* event_to_wire */
-  error,            /* error */
-  NULL,             /* error_string */
-};
-
-static XEXT_GENERATE_CLOSE_DISPLAY(close_display, dri2_info);
-static XEXT_GENERATE_FIND_DISPLAY(find_display, dri2_info,
-                                  dri2_name, &dri2_hooks, 0, NULL);
-
-
-static Bool
-wire_to_event( Display *dpy,
-               XEvent *re,
-               xEvent *event )
-{
-    XExtDisplayInfo *info = find_display(dpy);
-
-    DRI2CheckExtension(dpy, info, False);
-
-    TRACE("dri2 wire_to_event\n");
-
-    return False;
-}
-
-static Status
-event_to_wire( Display *dpy,
-               XEvent *re,
-               xEvent *event )
-{
-    XExtDisplayInfo *info = find_display(dpy);
-
-    DRI2CheckExtension(dpy, info, False);
-
-    TRACE("dri2 event_to_wire\n");
-
-    return False;
-}
-
-static int
-error( Display *dpy,
-       xError *err,
-       XExtCodes *codes,
-       int *ret_code )
-{
-    TRACE("dri2 error\n");
-
-    return False;
-}
-
-/*** Actual API begins here ***/
-
-Bool
-DRI2QueryExtension( Display * dpy/* , int *event_basep, int *error_basep */ )
-{
-    XExtDisplayInfo *info = find_display(dpy);
-
-    if (XextHasExtension(info)) {
-        /**event_basep = info->codes->first_event;
-        *error_basep = info->codes->first_error;*/
-        return True;
-    }
-
-    return False;
-}
-
-Bool
-DRI2QueryVersion( Display *dpy,
-                  unsigned *major,
-                  unsigned *minor )
-{
-    static const int nevents[] = { 0, 0, 1, 2 };
-    static const int nev = sizeof(nevents)/sizeof(*nevents) - 1;
-
-    XExtDisplayInfo *info = find_display(dpy);
-    xDRI2QueryVersionReply rep;
-    xDRI2QueryVersionReq *req;
-    int i, e;
-
-    DRI2CheckExtension(dpy, info, False);
-
-    LockDisplay(dpy);
-    GetReq(DRI2QueryVersion, req);
-    req->reqType = info->codes->major_opcode;
-    req->dri2ReqType = X_DRI2QueryVersion;
-    req->majorVersion = *major;
-    req->minorVersion = *minor;
-    if (!_XReply(dpy, (xReply *)&rep, 0, xFalse)) {
-        UnlockDisplay(dpy);
-        SyncHandle();
-        return False;
-    }
-    *major = rep.majorVersion;
-    *minor = rep.minorVersion;
-    UnlockDisplay(dpy);
-    SyncHandle();
-
-    e = (rep.minorVersion < nev) ? nevents[rep.minorVersion] : nevents[nev];
-    for (i = 0; i < e; ++i) {
-        XESetWireToEvent(dpy, info->codes->first_event + i, wire_to_event);
-        XESetEventToWire(dpy, info->codes->first_event + i, event_to_wire);
-    }
-
-    return True;
-}
-
-#define XALIGN(x) (((x) + 3) & (~3))
-
-Bool
-DRI2Connect( Display *dpy,
-             XID window,
-             unsigned driver_type,
-             char **driver,
-             char **device )
-{
-    XExtDisplayInfo *info = find_display(dpy);
-    xDRI2ConnectReply rep;
-    xDRI2ConnectReq *req;
-    int dev_len, driv_len;
-
-    DRI2CheckExtension(dpy, info, False);
-
-    LockDisplay(dpy);
-    GetReq(DRI2Connect, req);
-    req->reqType = info->codes->major_opcode;
-    req->dri2ReqType = X_DRI2Connect;
-    req->window = window;
-    req->driverType = driver_type;
-    if (!_XReply(dpy, (xReply *)&rep, 0, xFalse)) {
-        UnlockDisplay(dpy);
-        SyncHandle();
-        return False;
-    }
-
-    /* check string lengths */
-    dev_len = rep.deviceNameLength;
-    driv_len = rep.driverNameLength;
-    if (dev_len == 0 || driv_len == 0) {
-        _XEatData(dpy, XALIGN(dev_len) + XALIGN(driv_len));
-        UnlockDisplay(dpy);
-        SyncHandle();
-        return False;
-    }
-
-    /* read out driver */
-    *driver = HeapAlloc(GetProcessHeap(), 0, driv_len + 1);
-    if (!*driver) {
-        _XEatData(dpy, XALIGN(dev_len) + XALIGN(driv_len));
-        UnlockDisplay(dpy);
-        SyncHandle();
-        return False;
-    }
-    _XReadPad(dpy, *driver, driv_len);
-    (*driver)[driv_len] = '\0';
-
-    /* read out device */
-    *device = HeapAlloc(GetProcessHeap(), 0, dev_len + 1);
-    if (!*device) {
-        HeapFree(GetProcessHeap(), 0, *driver);
-        _XEatData(dpy, XALIGN(dev_len));
-        UnlockDisplay(dpy);
-        SyncHandle();
-        return False;
-    }
-    _XReadPad(dpy, *device, dev_len);
-    (*device)[dev_len] = '\0';
-
-    UnlockDisplay(dpy);
-    SyncHandle();
-
-    return True;
-}
-
-Bool
-DRI2Authenticate( Display *dpy,
-                  XID window,
-                  uint32_t token )
-{
-    XExtDisplayInfo *info = find_display(dpy);
-    xDRI2AuthenticateReply rep;
-    xDRI2AuthenticateReq *req;
-
-    DRI2CheckExtension(dpy, info, False);
-
-    LockDisplay(dpy);
-    GetReq(DRI2Authenticate, req);
-    req->reqType = info->codes->major_opcode;
-    req->dri2ReqType = X_DRI2Authenticate;
-    req->window = window;
-    req->magic = token;
-    if (!_XReply(dpy, (xReply *)&rep, 0, xFalse)) {
-        UnlockDisplay(dpy);
-        SyncHandle();
-        return False;
-    }
-    UnlockDisplay(dpy);
-    SyncHandle();
-
-    return rep.authenticated ? True : False;
-}
-
-void
-DRI2CreateDrawable( Display *dpy,
-                    XID drawable )
-{
-    XExtDisplayInfo *info = find_display(dpy);
-    xDRI2CreateDrawableReq *req;
-
-    DRI2CheckExtension(dpy, info, );
-
-    LockDisplay(dpy);
-    GetReq(DRI2CreateDrawable, req);
-    req->reqType = info->codes->major_opcode;
-    req->dri2ReqType = X_DRI2CreateDrawable;
-    req->drawable = drawable;
-    UnlockDisplay(dpy);
-    SyncHandle();
-}
-
-void
-DRI2DestroyDrawable( Display *dpy,
-                     XID drawable )
-{
-    XExtDisplayInfo *info = find_display(dpy);
-    xDRI2DestroyDrawableReq *req;
-
-    DRI2CheckExtension(dpy, info, );
-
-    LockDisplay(dpy);
-    GetReq(DRI2DestroyDrawable, req);
-    req->reqType = info->codes->major_opcode;
-    req->dri2ReqType = X_DRI2DestroyDrawable;
-    req->drawable = drawable;
-    UnlockDisplay(dpy);
-    SyncHandle();
-}
-
-static unsigned
-get_buffers( Display *dpy,
-             unsigned reqtype,
-             XID drawable,
-             const unsigned *attachments,
-             unsigned attach_count,
-             unsigned *width,
-             unsigned *height,
-             DRI2Buffer **buffers )
-{
-    XExtDisplayInfo *info = find_display(dpy);
-    xDRI2GetBuffersReply rep;
-    xDRI2GetBuffersReq *req;
-    xDRI2Buffer buf;
-    unsigned i, mult = (reqtype == X_DRI2GetBuffersWithFormat) ? 2 : 1;
-
-    DRI2CheckExtension(dpy, info, False);
-
-    LockDisplay(dpy);
-    GetReqExtra(DRI2GetBuffers, attach_count*sizeof(CARD32)*mult, req);
-    req->reqType = info->codes->major_opcode;
-    req->dri2ReqType = reqtype;
-    req->drawable = drawable;
-    req->count = attach_count;
-    /* copy in attachments */
-    for (i = 0; i < attach_count*mult; ++i) {
-        ((CARD32 *)&req[1])[i] = attachments[i];
-    }
-    if (!_XReply(dpy, (xReply *)&rep, 0, xFalse)) {
-        UnlockDisplay(dpy);
-        SyncHandle();
-        return False;
-    }
-
-    if (rep.count != 0) {
-        *buffers = HeapAlloc(GetProcessHeap(), 0,
-                             rep.count * sizeof(DRI2Buffer));
-        if (!*buffers) {
-            _XEatData(dpy, rep.count * sizeof(buf));
-            UnlockDisplay(dpy);
-            SyncHandle();
-            return False;
-        }
-
-        for (i = 0; i < rep.count; ++i) {
-            _XReadPad(dpy, (char *)&buf, sizeof(buf));
-            (*buffers)[i].attachment = buf.attachment;
-            (*buffers)[i].name = buf.name;
-            (*buffers)[i].pitch = buf.pitch;
-            (*buffers)[i].cpp = buf.cpp;
-            (*buffers)[i].flags = buf.flags;
-        }
-    }
-
-    *width = rep.width;
-    *height = rep.height;
-
-    UnlockDisplay(dpy);
-    SyncHandle();
-
-    return rep.count;
-}
-
-unsigned
-DRI2GetBuffers( Display *dpy,
-                XID drawable,
-                const unsigned *attachments,
-                unsigned attach_count,
-                unsigned *width,
-                unsigned *height,
-                DRI2Buffer **buffers )
-{
-    return get_buffers(dpy, X_DRI2GetBuffers, drawable, attachments,
-                       attach_count, width, height, buffers);
-}
-
-unsigned
-DRI2GetBuffersWithFormat( Display *dpy,
-                          XID drawable,
-                          const unsigned *attachments,
-                          unsigned attach_count,
-                          unsigned *width,
-                          unsigned *height,
-                          DRI2Buffer **buffers )
-{
-    return get_buffers(dpy, X_DRI2GetBuffersWithFormat, drawable, attachments,
-                       attach_count, width, height, buffers);
-}
-
-Bool
-DRI2CopyRegion( Display *dpy,
-                XID drawable,
-                XserverRegion region,
-                unsigned dest,
-                unsigned src )
-{
-    XExtDisplayInfo *info = find_display(dpy);
-    xDRI2CopyRegionReply rep;
-    xDRI2CopyRegionReq *req;
-
-    DRI2CheckExtension(dpy, info, False);
-
-    LockDisplay(dpy);
-    GetReq(DRI2CopyRegion, req);
-    req->reqType = info->codes->major_opcode;
-    req->dri2ReqType = X_DRI2CopyRegion;
-    req->drawable = drawable;
-    req->region = region;
-    req->dest = dest;
-    req->src = src;
-    if (!_XReply(dpy, (xReply *)&rep, 0, xFalse)) {
-        UnlockDisplay(dpy);
-        SyncHandle();
-        return False;
-    }
-    UnlockDisplay(dpy);
-    SyncHandle();
-
-    return True;
-}
-
-#endif /* defined(SONAME_LIBXEXT) && defined(SONAME_LIBXFIXES) */
diff --git a/dlls/winex11.drv/dri2.h b/dlls/winex11.drv/dri2.h
deleted file mode 100644
index 38c0252..0000000
--- a/dlls/winex11.drv/dri2.h
+++ /dev/null
@@ -1,101 +0,0 @@
-/*
- * Wine X11DRV DRI2 interface
- *
- * Copyright 2013 Joakim Sindholt
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
- */
-
-#ifndef __WINE_DRI2_H
-#define __WINE_DRI2_H
-
-#ifndef __WINE_CONFIG_H
-# error You must include config.h to use this header
-#endif
-
-#if defined(SONAME_LIBXEXT) && defined(SONAME_LIBXFIXES)
-
-#include <X11/Xlib.h>
-#include <X11/extensions/Xfixes.h>
-#include <X11/extensions/dri2tokens.h>
-#include <X11/extensions/dri2proto.h>
-
-#include <stdint.h>
-
-typedef struct
-{
-   unsigned attachment;
-   unsigned name;
-   unsigned pitch;
-   unsigned cpp;
-   unsigned flags;
-} DRI2Buffer;
-
-Bool
-DRI2QueryExtension( Display * dpy/* , int *event_basep, int *error_basep */ );
-
-Bool
-DRI2QueryVersion( Display *dpy,
-                  unsigned *major,
-                  unsigned *minor );
-
-Bool
-DRI2Connect( Display *dpy,
-             XID window,
-             unsigned driver_type,
-             char **driver,
-             char **device );
-
-Bool
-DRI2Authenticate( Display *dpy,
-                  XID window,
-                  uint32_t token );
-
-void
-DRI2CreateDrawable( Display *dpy,
-                    XID drawable );
-
-void
-DRI2DestroyDrawable( Display *dpy,
-                     XID drawable );
-
-unsigned
-DRI2GetBuffers( Display *dpy,
-                XID drawable,
-                const unsigned *attachments,
-                unsigned attach_count,
-                unsigned *width,
-                unsigned *height,
-                DRI2Buffer **buffers );
-
-unsigned
-DRI2GetBuffersWithFormat( Display *dpy,
-                          XID drawable,
-                          const unsigned *attachments,
-                          unsigned attach_count,
-                          unsigned *width,
-                          unsigned *height,
-                          DRI2Buffer **buffers );
-
-Bool
-DRI2CopyRegion( Display *dpy,
-                XID drawable,
-                XserverRegion region,
-                unsigned dest,
-                unsigned src );
-
-#endif /* defined(SONAME_LIBXEXT) && defined(SONAME_LIBXFIXES) */
-
-#endif /* __WINE_DRI2_H */
diff --git a/dlls/winex11.drv/dri3.c b/dlls/winex11.drv/dri3.c
new file mode 100644
index 0000000..0ea1c54
--- /dev/null
+++ b/dlls/winex11.drv/dri3.c
@@ -0,0 +1,729 @@
+/*
+ * Wine X11DRV DRI3 interface
+ *
+ * Copyright 2014 Axel Davy
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+
+#include "config.h"
+#include "wine/debug.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(x11drv);
+
+#if defined(SONAME_LIBXEXT) && defined(SONAME_LIBXFIXES)
+
+#include "x11drv.h"
+#include "wine/d3dadapter.h"
+
+#include <stdlib.h>
+#include <fcntl.h>
+#include <X11/Xlib.h>
+#include <X11/extensions/Xfixes.h>
+#include <X11/Xlib-xcb.h>
+
+#include "xfixes.h"
+#include "dri3.h"
+#include <pthread.h>
+#include "winbase.h" /* for Sleep */
+
+
+BOOL
+DRI3CheckExtension(Display *dpy, int major, int minor)
+{
+    xcb_connection_t *xcb_connection = XGetXCBConnection(dpy);
+    xcb_dri3_query_version_cookie_t dri3_cookie;
+    xcb_dri3_query_version_reply_t *dri3_reply;
+    xcb_generic_error_t *error;
+    const xcb_query_extension_reply_t *extension;
+
+    xcb_prefetch_extension_data(xcb_connection, &xcb_dri3_id);
+
+    extension = xcb_get_extension_data(xcb_connection, &xcb_dri3_id);
+    if (!(extension && extension->present)) {
+        TRACE("DRI3 extension is not present\n");
+        return FALSE;
+    }
+
+    dri3_cookie = xcb_dri3_query_version(xcb_connection, major, minor);
+
+    dri3_reply = xcb_dri3_query_version_reply(xcb_connection, dri3_cookie, &error);
+    if (!dri3_reply) {
+        free(error);
+        TRACE("Issue getting requested version of DRI3: %d,%d\n", major, minor);
+        return FALSE;
+    }
+
+    TRACE("DRI3 version %d,%d found. %d %d requested\n", major, minor, (int)dri3_reply->major_version, (int)dri3_reply->minor_version);
+    free(dri3_reply);
+
+    return TRUE;
+}
+
+BOOL
+PRESENTCheckExtension(Display *dpy, int major, int minor)
+{
+    xcb_connection_t *xcb_connection = XGetXCBConnection(dpy);
+    xcb_present_query_version_cookie_t present_cookie;
+    xcb_present_query_version_reply_t *present_reply;
+    xcb_generic_error_t *error;
+    const xcb_query_extension_reply_t *extension;
+
+    xcb_prefetch_extension_data(xcb_connection, &xcb_present_id);
+
+    extension = xcb_get_extension_data(xcb_connection, &xcb_present_id);
+    if (!(extension && extension->present)) {
+        TRACE("PRESENT extension is not present\n");
+        return FALSE;
+    }
+
+    present_cookie = xcb_present_query_version(xcb_connection, major, minor);
+
+    present_reply = xcb_present_query_version_reply(xcb_connection, present_cookie, &error);
+    if (!present_reply) {
+        free(error);
+        TRACE("Issue getting requested version of PRESENT: %d,%d\n", major, minor);
+        return FALSE;
+    }
+
+    TRACE("PRESENT version %d,%d found. %d %d requested\n", major, minor, (int)present_reply->major_version, (int)present_reply->minor_version);
+    free(present_reply);
+
+    return TRUE;
+}
+
+BOOL
+DRI3Open(Display *dpy, int screen, int *device_fd)
+{
+    xcb_dri3_open_cookie_t cookie;
+    xcb_dri3_open_reply_t *reply;
+    xcb_connection_t *xcb_connection = XGetXCBConnection(dpy);
+    int fd;
+    Window root = RootWindow(dpy, screen);
+
+    cookie = xcb_dri3_open(xcb_connection, root, 0);
+
+    reply = xcb_dri3_open_reply(xcb_connection, cookie, NULL);
+    if (!reply)
+        return FALSE;
+
+    if (reply->nfd != 1) {
+        free(reply);
+        return FALSE;
+    }
+
+    fd = xcb_dri3_open_reply_fds(xcb_connection, reply)[0];
+    fcntl(fd, F_SETFD, FD_CLOEXEC);
+
+    *device_fd = fd;
+
+    return TRUE;
+}
+
+BOOL
+DRI3PixmapFromDmaBuf(Display *dpy, int screen, int fd, int width, int height, int stride, int depth, int bpp, Pixmap *pixmap)
+{
+    xcb_connection_t *xcb_connection = XGetXCBConnection(dpy);
+    Window root = RootWindow(dpy, screen);
+    xcb_void_cookie_t cookie;
+    xcb_generic_error_t *error;
+
+    cookie = xcb_dri3_pixmap_from_buffer_checked(xcb_connection,
+                                                (*pixmap = xcb_generate_id(xcb_connection)),
+                                                root,
+                                                0,
+                                                width, height, stride,
+                                                depth, bpp, fd);
+    error = xcb_request_check(xcb_connection, cookie); /* performs a flush */
+    if (error) {
+        ERR("Error using DRI3 to convert a DmaBufFd to pixmap\n");
+        return FALSE;
+    }
+    return TRUE;
+}
+
+BOOL
+DRI3DmaBufFromPixmap(Display *dpy, Pixmap pixmap, int *fd, int *width, int *height, int *stride, int *depth, int *bpp)
+{
+    xcb_connection_t *xcb_connection = XGetXCBConnection(dpy);
+    xcb_dri3_buffer_from_pixmap_cookie_t bp_cookie;
+    xcb_dri3_buffer_from_pixmap_reply_t  *bp_reply;
+
+    bp_cookie = xcb_dri3_buffer_from_pixmap(xcb_connection, pixmap);
+    bp_reply = xcb_dri3_buffer_from_pixmap_reply(xcb_connection, bp_cookie, NULL);
+    if (!bp_reply)
+        return FALSE;
+    *fd = xcb_dri3_buffer_from_pixmap_reply_fds(xcb_connection, bp_reply)[0];
+    *width = bp_reply->width;
+    *height = bp_reply->height;
+    *stride = bp_reply->stride;
+    *depth = bp_reply->depth;
+    *bpp = bp_reply->depth;
+    return TRUE;
+}
+
+struct PRESENTPriv {
+    xcb_connection_t *xcb_connection;
+    XID window;
+    uint64_t last_msc;
+    uint64_t last_target;
+    uint32_t last_serial;
+    xcb_special_event_t *special_event;
+    PRESENTPixmapPriv *first_present_priv;
+    int pixmap_present_pending;
+    BOOL notify_with_serial_pending;
+    pthread_mutex_t mutex_present; /* protect readind/writing present_priv things */
+    pthread_mutex_t mutex_xcb_wait;
+    BOOL xcb_wait;
+};
+
+struct PRESENTPixmapPriv {
+    PRESENTpriv *present_priv;
+    Pixmap pixmap;
+    BOOL released;
+    BOOL present_complete_pending;
+    uint32_t present_pending_serial;
+    BOOL last_present_was_flip;
+    PRESENTPixmapPriv *next;
+};
+
+static PRESENTPixmapPriv *PRESENTFindPixmapPriv(PRESENTpriv *present_priv, uint32_t serial)
+{
+    PRESENTPixmapPriv *current = present_priv->first_present_priv;
+
+    while (current) {
+        if (current->present_pending_serial == serial)
+            return current;
+        current = current->next;
+    }
+    return NULL;
+}
+
+static void PRESENThandle_events(PRESENTpriv *present_priv, xcb_present_generic_event_t *ge)
+{
+    PRESENTPixmapPriv *present_pixmap_priv = NULL;
+
+    switch (ge->evtype) {
+        case XCB_PRESENT_COMPLETE_NOTIFY: {
+            xcb_present_complete_notify_event_t *ce = (void *) ge;
+            if (ce->kind == XCB_PRESENT_COMPLETE_KIND_NOTIFY_MSC) {
+                if (ce->serial)
+                    present_priv->notify_with_serial_pending = FALSE;
+                free(ce);
+                return;
+            }
+            present_pixmap_priv = PRESENTFindPixmapPriv(present_priv, ce->serial);
+            if (!present_pixmap_priv || ce->kind != XCB_PRESENT_COMPLETE_KIND_PIXMAP) {
+                ERR("FATAL ERROR: PRESENT handling failed\n");
+                free(ce);
+                return;
+            }
+            present_pixmap_priv->present_complete_pending = FALSE;
+            switch (ce->mode) {
+                case XCB_PRESENT_COMPLETE_MODE_FLIP:
+                    present_pixmap_priv->last_present_was_flip = TRUE;
+                    break;
+                case XCB_PRESENT_COMPLETE_MODE_COPY:
+                    present_pixmap_priv->last_present_was_flip = FALSE;
+                    break;
+            }
+            if (present_pixmap_priv->released)
+                present_pixmap_priv->present_pending_serial = 0;
+
+            present_priv->pixmap_present_pending--;
+            present_priv->last_msc = ce->msc;
+            break;
+        }
+        case XCB_PRESENT_EVENT_IDLE_NOTIFY: {
+            xcb_present_idle_notify_event_t *ie = (void *) ge;
+            present_pixmap_priv = PRESENTFindPixmapPriv(present_priv, ie->serial);
+            if (!present_pixmap_priv || present_pixmap_priv->pixmap != ie->pixmap) {
+                ERR("FATAL ERROR: PRESENT handling failed\n");
+                free(ie);
+                return;
+            }
+            present_pixmap_priv->released = TRUE;
+            if (!present_pixmap_priv->present_complete_pending)
+                present_pixmap_priv->present_pending_serial = 0;
+            break;
+        }
+    }
+    free(ge);
+}
+
+static void PRESENTflush_events(PRESENTpriv *present_priv, BOOL assert_no_other_thread_waiting)
+{
+    xcb_generic_event_t *ev;
+
+    if ((present_priv->xcb_wait && !assert_no_other_thread_waiting) || /* don't steal events to someone waiting */
+        !present_priv->special_event)
+        return;
+
+    while ((ev = xcb_poll_for_special_event(present_priv->xcb_connection, present_priv->special_event)) != NULL) {
+        PRESENThandle_events(present_priv, (void *) ev);
+    }
+}
+
+static BOOL PRESENTwait_events(PRESENTpriv *present_priv, BOOL allow_other_threads)
+{
+    xcb_generic_event_t *ev;
+
+    if (allow_other_threads) {
+        present_priv->xcb_wait = TRUE;
+        pthread_mutex_lock(&present_priv->mutex_xcb_wait);
+        pthread_mutex_unlock(&present_priv->mutex_present);
+    }
+    ev = xcb_wait_for_special_event(present_priv->xcb_connection, present_priv->special_event);
+    if (allow_other_threads) {
+        pthread_mutex_unlock(&present_priv->mutex_xcb_wait);
+        pthread_mutex_lock(&present_priv->mutex_present);
+        present_priv->xcb_wait = FALSE;
+    }
+    if (!ev) {
+        ERR("FATAL error: xcb had an error\n");
+        return FALSE;
+    }
+
+    PRESENThandle_events(present_priv, (void *) ev);
+    return TRUE;
+}
+
+BOOL
+PRESENTInit(Display *dpy, PRESENTpriv **present_priv)
+{
+    *present_priv = (PRESENTpriv *) calloc(1, sizeof(PRESENTpriv));
+    if (!*present_priv) {
+        return FALSE;
+    }
+    (*present_priv)->xcb_connection = XGetXCBConnection(dpy);
+    pthread_mutex_init(&(*present_priv)->mutex_present, NULL);
+    return TRUE;
+}
+
+static void PRESENTForceReleases(PRESENTpriv *present_priv)
+{
+    PRESENTPixmapPriv *current = NULL;
+
+    if (!present_priv->window)
+        return;
+
+    /* There should be no other thread listening for events here.
+     * This can happen when hDestWindowOverride changes without reset.
+     * This case should never happen, but can happen in theory.*/
+    if (present_priv->xcb_wait) {
+        xcb_present_notify_msc(present_priv->xcb_connection, present_priv->window, 0, 0, 0, 0);
+        xcb_flush(present_priv->xcb_connection);
+        pthread_mutex_lock(&present_priv->mutex_xcb_wait);
+        pthread_mutex_unlock(&present_priv->mutex_xcb_wait);
+        /* the problem here is that we don't have access to the event the other thread got.
+         * It is either presented event, idle event or notify event.
+         */
+        while (present_priv->pixmap_present_pending >= 1)
+            PRESENTwait_events(present_priv, FALSE);
+        PRESENTflush_events(present_priv, TRUE);
+        /* Remaining events to come can be a pair of present/idle,
+         * or an idle, or nothing. To be sure we are after all pixmaps
+         * have been presented, add an event to the queue that can only
+         * be after the present event, then if we receive an event more,
+         * we are sure all pixmaps were presented */
+        present_priv->notify_with_serial_pending = TRUE;
+        xcb_present_notify_msc(present_priv->xcb_connection, present_priv->window, 1, present_priv->last_target + 5, 0, 0);
+        xcb_flush(present_priv->xcb_connection);
+        while (present_priv->notify_with_serial_pending)
+            PRESENTwait_events(present_priv, FALSE);
+        /* Now we are sure we are not expecting any new event */
+    } else {
+        while (present_priv->pixmap_present_pending) /* wait all sent pixmaps are presented */
+            PRESENTwait_events(present_priv, FALSE);
+        PRESENTflush_events(present_priv, TRUE); /* may be remaining idle event */
+        /* Since idle events are send with the complete events when it is not flips,
+         * we are not expecting any new event here */
+    }
+
+    current = present_priv->first_present_priv;
+    while (current) {
+        if (!current->released) {
+            if (!current->last_present_was_flip && !present_priv->xcb_wait) {
+                ERR("ERROR: a pixmap seems not released by PRESENT for no reason. Code bug.\n");
+            } else {
+                /* Present the same pixmap with a non-valid part to force the copy mode and the releases */
+                xcb_xfixes_region_t valid, update;
+                xcb_rectangle_t rect_update;
+                rect_update.x = 0;
+                rect_update.y = 0;
+                rect_update.width = 8;
+                rect_update.height = 1;
+                valid = xcb_generate_id(present_priv->xcb_connection);
+                update = xcb_generate_id(present_priv->xcb_connection);
+                xcb_xfixes_create_region(present_priv->xcb_connection, valid, 1, &rect_update);
+                xcb_xfixes_create_region(present_priv->xcb_connection, update, 1, &rect_update);
+                /* here we know the pixmap has been presented. Thus if it is on screen,
+                 * the following request can only make it released by the server if it is not */
+                xcb_present_pixmap(present_priv->xcb_connection, present_priv->window,
+                                   current->pixmap, 0, valid, update, 0, 0, None, None,
+                                   None, XCB_PRESENT_OPTION_COPY | XCB_PRESENT_OPTION_ASYNC, 0, 0, 0, 0, NULL);
+                xcb_flush(present_priv->xcb_connection);
+                PRESENTwait_events(present_priv, FALSE); /* by assumption this can only be idle event */
+                PRESENTflush_events(present_priv, TRUE); /* Shoudln't be needed */
+            }
+        }
+        current = current->next;
+    }
+    /* Now all pixmaps are released (possibility if xcb_wait is true that one is not aware yet),
+     * and we don't expect any new Present event to come from Xserver */
+}
+
+static void PRESENTFreeXcbQueue(PRESENTpriv *present_priv)
+{
+    if (present_priv->window) {
+        xcb_unregister_for_special_event(present_priv->xcb_connection, present_priv->special_event);
+        present_priv->last_msc = 0;
+        present_priv->last_target = 0;
+        present_priv->last_serial = 0;
+        present_priv->special_event = NULL;
+    }
+}
+
+static BOOL PRESENTPrivChangeWindow(PRESENTpriv *present_priv, XID window)
+{
+    xcb_void_cookie_t cookie;
+    xcb_generic_error_t *error;
+    xcb_present_event_t eid;
+
+    PRESENTForceReleases(present_priv);
+    PRESENTFreeXcbQueue(present_priv);
+    present_priv->window = window;
+
+    if (window) {
+        cookie = xcb_present_select_input_checked(present_priv->xcb_connection,
+                                                  (eid = xcb_generate_id(present_priv->xcb_connection)),
+                                                  window,
+                                                  XCB_PRESENT_EVENT_MASK_COMPLETE_NOTIFY|
+                                                  XCB_PRESENT_EVENT_MASK_IDLE_NOTIFY);
+        present_priv->special_event = xcb_register_for_special_xge(present_priv->xcb_connection,
+                                                                   &xcb_present_id,
+                                                                   eid, NULL);
+        error = xcb_request_check(present_priv->xcb_connection, cookie); /* performs a flush */
+        if (error || !present_priv->special_event) {
+            ERR("FAILED to use the X PRESENT extension. Was the destination a window ?\n");
+            if (present_priv->special_event)
+                xcb_unregister_for_special_event(present_priv->xcb_connection, present_priv->special_event);
+            present_priv->special_event = NULL;
+            present_priv->window = 0;
+        }
+    }
+    return (present_priv->window != 0);
+}
+
+void
+PRESENTDestroy(Display *dpy, PRESENTpriv *present_priv)
+{
+    PRESENTPixmapPriv *current = NULL;
+
+    pthread_mutex_lock(&present_priv->mutex_present);
+
+    PRESENTForceReleases(present_priv);
+
+    current = present_priv->first_present_priv;
+    while (current) {
+        PRESENTPixmapPriv *next = current->next;
+        XFreePixmap(dpy, current->pixmap);
+        free(current);
+        current = next;
+    }
+
+    PRESENTFreeXcbQueue(present_priv);
+
+    pthread_mutex_unlock(&present_priv->mutex_present);
+    pthread_mutex_destroy(&present_priv->mutex_present);
+
+    free(present_priv);
+}
+
+BOOL
+PRESENTPixmapInit(PRESENTpriv *present_priv, Pixmap pixmap, PRESENTPixmapPriv **present_pixmap_priv)
+{
+    *present_pixmap_priv = (PRESENTPixmapPriv *) calloc(1, sizeof(PRESENTPixmapPriv));
+    if (!*present_pixmap_priv) {
+        return FALSE;
+    }
+    pthread_mutex_lock(&present_priv->mutex_present);
+    (*present_pixmap_priv)->released = TRUE;
+    (*present_pixmap_priv)->pixmap = pixmap;
+    (*present_pixmap_priv)->present_priv = present_priv;
+    (*present_pixmap_priv)->next = present_priv->first_present_priv;
+    present_priv->first_present_priv = *present_pixmap_priv;
+    pthread_mutex_unlock(&present_priv->mutex_present);
+    return TRUE;
+}
+
+BOOL
+PRESENTTryFreePixmap(PRESENTPixmapPriv *present_pixmap_priv)
+{
+    PRESENTpriv *present_priv = present_pixmap_priv->present_priv;
+    PRESENTPixmapPriv *current;
+
+    pthread_mutex_lock(&present_priv->mutex_present);
+
+    if (!present_pixmap_priv->released) {
+        pthread_mutex_unlock(&present_priv->mutex_present);
+        return FALSE;
+    }
+
+    if (present_priv->first_present_priv == present_pixmap_priv) {
+        present_priv->first_present_priv = present_pixmap_priv->next;
+        goto free_priv;
+    }
+
+    current = present_priv->first_present_priv;
+    while (current->next != present_pixmap_priv)
+        current = current->next;
+    current->next = present_pixmap_priv->next;
+free_priv:
+    free(present_pixmap_priv);
+    pthread_mutex_unlock(&present_priv->mutex_present);
+    return TRUE;
+}
+
+BOOL
+PRESENTHelperCopyFront(Display *dpy, PRESENTPixmapPriv *present_pixmap_priv)
+{
+    PRESENTpriv *present_priv = present_pixmap_priv->present_priv;
+    xcb_void_cookie_t cookie;
+    xcb_generic_error_t *error;
+    Window root_return;
+    int x_return, y_return;
+    unsigned int width_return, height_return;
+    unsigned int border_width_return;
+    unsigned int depth_return;
+    uint32_t v;
+    xcb_gcontext_t gc;
+
+    pthread_mutex_lock(&present_priv->mutex_present);
+
+    if (!present_priv->window) {
+        pthread_mutex_unlock(&present_priv->mutex_present);
+        return FALSE;
+    }
+    XGetGeometry(dpy, present_pixmap_priv->pixmap, &root_return, &x_return, &y_return, &width_return,
+                 &height_return, &border_width_return, &depth_return);
+    v = 0;
+    xcb_create_gc(present_priv->xcb_connection,
+                  (gc = xcb_generate_id(present_priv->xcb_connection)),
+                  present_priv->window,
+                  XCB_GC_GRAPHICS_EXPOSURES,
+                  &v);
+    cookie = xcb_copy_area_checked(present_priv->xcb_connection,
+                                   present_priv->window,
+                                   present_pixmap_priv->pixmap,
+                                   gc,
+                                   0, 0, 0, 0,
+                                   width_return, height_return);
+    error = xcb_request_check(present_priv->xcb_connection, cookie);
+    xcb_free_gc(present_priv->xcb_connection, gc);
+    pthread_mutex_unlock(&present_priv->mutex_present);
+    return (error != NULL);
+}
+
+BOOL
+PRESENTPixmap(Display *dpy, XID window,
+              PRESENTPixmapPriv *present_pixmap_priv, D3DPRESENT_PARAMETERS *pPresentationParameters,
+              const RECT *pSourceRect, const RECT *pDestRect, const RGNDATA *pDirtyRegion)
+{
+    PRESENTpriv *present_priv = present_pixmap_priv->present_priv;
+    xcb_void_cookie_t cookie;
+    xcb_generic_error_t *error;
+    int64_t target_msc, presentationInterval;
+    int32_t serial;
+    xcb_xfixes_region_t valid, update;
+    int16_t x_off, y_off;
+    uint32_t options = XCB_PRESENT_OPTION_NONE;
+
+    pthread_mutex_lock(&present_priv->mutex_present);
+
+    if (window != present_priv->window)
+        PRESENTPrivChangeWindow(present_priv, window);
+
+    if (!window) {
+        ERR("ERROR: Try to Present a pixmap on a NULL window\n");
+        pthread_mutex_unlock(&present_priv->mutex_present);
+        return FALSE;
+    }
+
+    PRESENTflush_events(present_priv, FALSE);
+
+    target_msc = present_priv->last_msc;
+    switch(pPresentationParameters->PresentationInterval) {
+        case D3DPRESENT_INTERVAL_DEFAULT:
+        case D3DPRESENT_INTERVAL_ONE:
+            presentationInterval = 1;
+            break;
+        case D3DPRESENT_INTERVAL_TWO:
+            presentationInterval = 2;
+            break;
+        case D3DPRESENT_INTERVAL_THREE:
+            presentationInterval = 3;
+            break;
+        case D3DPRESENT_INTERVAL_FOUR:
+            presentationInterval = 4;
+            break;
+        case D3DPRESENT_INTERVAL_IMMEDIATE:
+        default:
+            presentationInterval = 0;
+            options |= XCB_PRESENT_OPTION_ASYNC;
+            break;
+    }
+    target_msc += presentationInterval * (present_priv->pixmap_present_pending + 1);
+    serial = present_priv->last_serial + 1;
+
+    /* Note: PRESENT defines some way to do partial copy:
+     * presentproto:
+     * 'x-off' and 'y-off' define the location in the window where
+     *  the 0,0 location of the pixmap will be presented. valid-area
+     *  and update-area are relative to the pixmap.
+     */
+    if (!pSourceRect && !pDestRect && !pDirtyRegion) {
+        valid = 0;
+        update = 0;
+        x_off = 0;
+        y_off = 0;
+    } else {
+        xcb_rectangle_t rect_update;
+        xcb_rectangle_t *rect_updates;
+        /* Get pixmap size */
+        Window root_return;
+        int x_return, y_return;
+        unsigned int width_return, height_return;
+        unsigned int border_width_return;
+        unsigned int depth_return;
+        int i;
+        XGetGeometry(dpy, present_pixmap_priv->pixmap, &root_return, &x_return, &y_return, &width_return,
+                     &height_return, &border_width_return, &depth_return);
+        rect_update.x = 0;
+        rect_update.y = 0;
+        rect_update.width = width_return;
+        rect_update.height = height_return;
+        x_off = 0;
+        y_off = 0;
+        if (pSourceRect) {
+            x_off = -pSourceRect->left;
+            y_off = -pSourceRect->top;
+            rect_update.x = pSourceRect->left;
+            rect_update.y = pSourceRect->top;
+            rect_update.width = pSourceRect->right - pSourceRect->left;
+            rect_update.height = pSourceRect->bottom - pSourceRect->top;
+        }
+        if (pDestRect) {
+            x_off += pDestRect->left;
+            y_off += pDestRect->top;
+            rect_update.width = pDestRect->right - pDestRect->left;
+            rect_update.height = pDestRect->bottom - pDestRect->top;
+            /* Note: the size of pDestRect and pSourceRect are supposed to be the same size
+             * because the driver would have done things to assure that. */
+        }
+        valid = xcb_generate_id(present_priv->xcb_connection);
+        update = xcb_generate_id(present_priv->xcb_connection);
+        xcb_xfixes_create_region(present_priv->xcb_connection, valid, 1, &rect_update);
+        if (pDirtyRegion && pDirtyRegion->rdh.nCount) {
+            rect_updates = (void *) calloc(pDirtyRegion->rdh.nCount, sizeof(xcb_rectangle_t));
+            for (i = 0; i < pDirtyRegion->rdh.nCount; i++)
+            {
+                RECT rc;
+                memcpy(&rc, pDirtyRegion->Buffer + i * sizeof(RECT), sizeof(RECT));
+                rect_update.x = rc.left;
+                rect_update.y = rc.top;
+                rect_update.width = rc.right - rc.left;
+                rect_update.height = rc.bottom - rc.top;
+                memcpy(rect_updates + i * sizeof(xcb_rectangle_t), &rect_update, sizeof(xcb_rectangle_t));
+            }
+            xcb_xfixes_create_region(present_priv->xcb_connection, update, pDirtyRegion->rdh.nCount, rect_updates);
+            free(rect_updates);
+        } else
+            xcb_xfixes_create_region(present_priv->xcb_connection, update, 1, &rect_update);
+    }
+    if (pPresentationParameters->SwapEffect == D3DSWAPEFFECT_COPY)
+        options |= XCB_PRESENT_OPTION_COPY;
+    cookie = xcb_present_pixmap_checked(present_priv->xcb_connection,
+                                        window,
+                                        present_pixmap_priv->pixmap,
+                                        serial, valid, update, x_off,
+                                        y_off, None, None, None, options,
+                                        target_msc, 0, 0, 0, NULL);
+    error = xcb_request_check(present_priv->xcb_connection, cookie); /* performs a flush */
+    if (error) {
+        Window root_return;
+        int x_pixmap, x_window, y_pixmap, y_window;
+        unsigned int width_pixmap, width_window, height_pixmap, height_window;
+        unsigned int border_width_return;
+        unsigned int depth_pixmap, depth_window;
+        int i;
+        XGetGeometry(dpy, present_pixmap_priv->pixmap, &root_return, &x_pixmap, &y_pixmap, &width_pixmap,
+                     &height_pixmap, &border_width_return, &depth_pixmap);
+        XGetGeometry(dpy, window, &root_return, &x_window, &y_window, &width_window,
+                     &height_window, &border_width_return, &depth_window);
+        ERR("Error using PRESENT. Here some debug info\n");
+        ERR("Pixmap: width=%d, height=%d, depth=%d, x=%d, y=%d\n", width_pixmap, height_pixmap, depth_pixmap, x_pixmap, y_pixmap);
+        ERR("Window: width=%d, height=%d, depth=%d, x=%d, y=%d\n", width_window, height_window, depth_window, x_window, y_window);
+        ERR("Present parameter: PresentationInterval=%d, BackBufferCount=%d, Pending presentations=%d\n",
+            pPresentationParameters->PresentationInterval,
+            pPresentationParameters->BackBufferCount,
+            present_priv->pixmap_present_pending
+           );
+        if (depth_pixmap != depth_window)
+            ERR("Depths are different. PRESENT needs the pixmap and the window have same depth\n");
+        pthread_mutex_unlock(&present_priv->mutex_present);
+        return FALSE;
+    }
+    present_priv->last_target = target_msc;
+    present_priv->last_serial = serial;
+    present_priv->pixmap_present_pending++;
+    present_pixmap_priv->present_complete_pending = TRUE;
+    present_pixmap_priv->present_pending_serial = serial;
+    present_pixmap_priv->released = FALSE;
+    pthread_mutex_unlock(&present_priv->mutex_present);
+    return TRUE;
+}
+
+BOOL
+PRESENTWaitPixmapReleased(PRESENTPixmapPriv *present_pixmap_priv)
+{
+    PRESENTpriv *present_priv = present_pixmap_priv->present_priv;
+
+    pthread_mutex_lock(&present_priv->mutex_present);
+
+    PRESENTflush_events(present_priv, FALSE);
+
+    while (!present_pixmap_priv->released) {
+        /* Note: following if should not happen because we'll never
+         * use two PRESENTWaitPixmapReleased in parallels on same window.
+         * However it would make it work in that case */
+        if (present_priv->xcb_wait) { /* we allow only one thread to dispatch events */
+            pthread_mutex_lock(&present_priv->mutex_xcb_wait);
+            /* here the other thread got an event but hasn't treated it yet */
+            pthread_mutex_unlock(&present_priv->mutex_xcb_wait);
+            pthread_mutex_unlock(&present_priv->mutex_present);
+            Sleep(10); /* Let it treat the event */
+            pthread_mutex_lock(&present_priv->mutex_present);
+        } else if (!PRESENTwait_events(present_priv, TRUE)) {
+            pthread_mutex_unlock(&present_priv->mutex_present);
+            return FALSE;
+        }
+    }
+    pthread_mutex_unlock(&present_priv->mutex_present);
+    return TRUE;
+}
+
+#endif /* defined(SONAME_LIBXEXT) && defined(SONAME_LIBXFIXES) */
diff --git a/dlls/winex11.drv/dri3.h b/dlls/winex11.drv/dri3.h
new file mode 100644
index 0000000..cfea9db
--- /dev/null
+++ b/dlls/winex11.drv/dri3.h
@@ -0,0 +1,85 @@
+/*
+ * Wine X11DRV DRI3 interface
+ *
+ * Copyright 2014 Axel Davy
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#ifndef __WINE_DRI3_H
+#define __WINE_DRI3_H
+
+#ifndef __WINE_CONFIG_H
+# error You must include config.h to use this header
+#endif
+
+#if defined(SONAME_LIBXEXT) && defined(SONAME_LIBXFIXES)
+
+#include <X11/extensions/Xfixes.h>
+#include <X11/Xlib.h>
+#include <X11/Xlib-xcb.h>
+#include <xcb/xcb.h>
+#include <xcb/dri3.h>
+#include <xcb/present.h>
+
+BOOL
+DRI3CheckExtension(Display *dpy, int major, int minor);
+
+BOOL
+PRESENTCheckExtension(Display *dpy, int major, int minor);
+
+BOOL
+DRI3Open(Display *dpy, int screen, int *device_fd);
+
+BOOL
+DRI3PixmapFromDmaBuf(Display *dpy, int screen, int fd, int width, int height, int stride, int depth, int bpp, Pixmap *pixmap);
+
+BOOL
+DRI3DmaBufFromPixmap(Display *dpy, Pixmap pixmap, int *fd, int *width, int *height, int *stride, int *depth, int *bpp);
+
+typedef struct PRESENTPriv PRESENTpriv;
+typedef struct PRESENTPixmapPriv PRESENTPixmapPriv;
+
+BOOL
+PRESENTInit(Display *dpy, PRESENTpriv **present_priv);
+
+/* will clean properly and free all PRESENTPixmapPriv associated to PRESENTpriv.
+ * PRESENTPixmapPriv should not be freed by something else.
+ * If never a PRESENTPixmapPriv has to be destroyed,
+ * please destroy the current PRESENTpriv and create a new one.
+ * This will take care than all pixmaps are released */
+void
+PRESENTDestroy(Display *dpy, PRESENTpriv *present_priv);
+
+BOOL
+PRESENTPixmapInit(PRESENTpriv *present_priv, Pixmap pixmap, PRESENTPixmapPriv **present_pixmap_priv);
+
+BOOL
+PRESENTTryFreePixmap(PRESENTPixmapPriv *present_pixmap_priv);
+
+BOOL
+PRESENTHelperCopyFront(Display *dpy, PRESENTPixmapPriv *present_pixmap_priv);
+
+BOOL
+PRESENTPixmap(Display *dpy, XID window,
+              PRESENTPixmapPriv *present_pixmap_priv, D3DPRESENT_PARAMETERS *pPresentationParameters,
+              const RECT *pSourceRect, const RECT *pDestRect, const RGNDATA *pDirtyRegion);
+
+BOOL
+PRESENTWaitPixmapReleased(PRESENTPixmapPriv *present_pixmap_priv);
+
+#endif /* defined(SONAME_LIBXEXT) && defined(SONAME_LIBXFIXES) */
+
+#endif /* __WINE_DRI3_H */
diff --git a/dlls/winex11.drv/init.c b/dlls/winex11.drv/init.c
index 0964a29..17b1776 100644
--- a/dlls/winex11.drv/init.c
+++ b/dlls/winex11.drv/init.c
@@ -472,7 +472,7 @@ static struct d3dadapter_funcs * X11DRV_wine_get_d3dadapter_driver( PHYSDEV dev,
 {
     struct d3dadapter_funcs *ret;
 
-    if (!(ret = get_d3d_dri2_driver( version )))
+    if (!(ret = get_d3d_dri3_driver( version )))
     {
         dev = GET_NEXT_PHYSDEV( dev, wine_get_d3dadapter_driver );
         ret = dev->funcs->wine_get_d3dadapter_driver( dev, version );
diff --git a/dlls/winex11.drv/x11drv.h b/dlls/winex11.drv/x11drv.h
index 5b598d6..68308b0 100644
--- a/dlls/winex11.drv/x11drv.h
+++ b/dlls/winex11.drv/x11drv.h
@@ -222,7 +222,7 @@ extern BOOL shape_layered_windows DECLSPEC_HIDDEN;
 extern const struct gdi_dc_funcs *X11DRV_XRender_Init(void) DECLSPEC_HIDDEN;
 
 extern struct opengl_funcs *get_glx_driver(UINT) DECLSPEC_HIDDEN;
-extern struct d3dadapter_funcs *get_d3d_dri2_driver(UINT) DECLSPEC_HIDDEN;
+extern struct d3dadapter_funcs *get_d3d_dri3_driver(UINT) DECLSPEC_HIDDEN;
 
 /* IME support */
 extern void IME_SetOpenStatus(BOOL fOpen) DECLSPEC_HIDDEN;
-- 
1.9.3

